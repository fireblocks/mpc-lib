@startuml

title mpc-lib
'- cmp_signature_preprocessed_data.h




'- key id 
'- request id
' void cmp_ecdsa_offline_signing_service::ecdsa_sign

' cmp_ecdsa_online_signing_service::get_si(
' clac sig.s = k(m + r * delta) +r(k * x + Chi)

' s = k ^-1 e + r (k^-1 *aplha + Beta - Beta)
' where e is message
' Calculate s = kâˆ’1 (z + r dA) mod n. If s=0, go back to step 3.
' r is x of public hey


/'
throw_cosigner_exception(GFp_curve_algebra_mul_scalars(curve, &tmp, sig.r, sizeof(elliptic_curve256_scalar_t), delta.data, sizeof(elliptic_curve256_scalar_t)));

'/ 
package mta {
    struct cmp_mta_message {
        byte_vector_t message
        byte_vector_t commitment
        byte_vector_t proof
    }


    struct cmp_mta_request {
        cmp_mta_message mta
        std::map<uint64_t, byte_vector_t> mta_proofs
        elliptic_curve_point A
        elliptic_curve_point B
        elliptic_curve_point Z
    }

    cmp_mta_request --> cmp_mta_message



    struct cmp_mta_response {
        map<uint64_t, cmp_mta_message> k_gamma_mta
        map<uint64_t, cmp_mta_message> k_x_mta
        elliptic_curve_point GAMMA
        map<uint64_t, byte_vector_t> gamma_proofs
    }

    struct cmp_mta_responses {
        commitments_sha256_t ack
        vector<cmp_mta_response> response
    }

    cmp_mta_responses --> cmp_mta_response

    struct cmp_mta_deltas {
        elliptic_curve_scalar delta
        elliptic_curve_point DELTA
        byte_vector_t proof
    }

}

package types {
    enum SIGNING_FLAGS {
        NONE         
        POSITIVE_R   
        EDDSA_KECCAK 
    }

    struct signing_block_data {
        byte_vector_t data
        vector<uint32_t> path
    }

    struct signing_data
    {
        HDChaincode chaincode
        vector<signing_block_data> blocks
    }

    signing_data --> signing_block_data

    struct recoverable_signature {
        elliptic_curve256_scalar_t r
        elliptic_curve256_scalar_t s
        uint8_t v
    }

    struct eddsa_signature {
        ed25519_point_t R
        ed25519_scalar_t s
    }

    struct ecdsa_signing_public_data {
        elliptic_curve_point A
        elliptic_curve_point B
        elliptic_curve_point Z
        elliptic_curve_point GAMMA
        byte_vector_t gamma_commitment
    }

    struct ecdsa_signing_data {
        elliptic_curve_scalar k
        elliptic_curve_scalar gamma
        elliptic_curve_scalar a
        elliptic_curve_scalar b
        elliptic_curve_scalar delta
        elliptic_curve_scalar chi
        elliptic_curve_point GAMMA
        byte_vector_t mta_request
        map<uint64_t, byte_vector_t> G_proofs
        map<uint64_t, ecdsa_signing_public_data> public_data
    }

    ecdsa_signing_data --> ecdsa_signing_public_data
}

class cmp_player_info {
    elliptic_curve_point public_share
    paillier_public_key paillier
    ring_pedersen_public ring_pedersen
}

class cmp_key_metadata{
    elliptic_curve256_point_t public_key
    uint8_t t
    uint8_t n
    cosigner_sign_algorithm algorithm
    uint64_t ttl
    commitments_sha256_t seed
    map<uint64_t, cmp_player_info> players_info
}

cmp_key_metadata --> cmp_player_info


struct auxiliary_keys {
    shared_ptr<struct paillier_private_key> paillier
    shared_ptr<struct ring_pedersen_private> ring_pedersen
}


abstract class platform_service {
    gen_random()
    get_current_tenantid()
    get_id_from_keyid()
    derive_initial_share() 
    encrypt_for_player()
    decrypt_message()
    backup_key()
    start_signing()
    fill_signing_info_from_metadata() 
    is_client_id()
}
platform_service -> cmp_key_metadata

abstract class cmp_key_persistency {
    key_exist()
    load_key()
    get_tenantid_from_keyid()

    load_key_metadata()
    load_auxiliary_keys()
}
cmp_key_persistency --> auxiliary_keys
cmp_key_persistency --> cmp_key_metadata

package setup {

    abstract class setup_key_persistency {
        store_key()
        store_key_metadata()
        store_auxiliary_keys()
        store_keyid_tenant_id()
        store_setup_data()
        load_setup_data()
        store_setup_commitments()
        setup_commitments()
        delete_temporary_key_data()
    }

    setup_key_persistency --|> cmp_key_persistency


    class cmp_setup_service {
        generate_setup_commitments()
        store_setup_commitments()
        generate_setup_proofs()
        verify_setup_proofs()
        create_secret()

        add_user_request()
        add_user()
    }

    cmp_setup_service --> platform_service
    cmp_setup_service --> setup_key_persistency
}

class eddsa_signature_data {
    elliptic_curve_scalar k
    elliptic_curve_point R
    elliptic_curve_scalar s
    vector<uint32_t> path
    byte_vector_t message
    uint32_t flags
}

class eddsa_signing_metadata {
    string key_id
    HDChaincode chaincode
    vector<eddsa_signature_data> sig_data
    set<uint64_t> signers_ids
    uint32_t version
}

eddsa_signing_metadata --> eddsa_signature_data

abstract class signing_persistency {
    store_signing_data()
    load_signing_data()
    update_signing_data()
    store_signing_commitments()
    load_signing_commitments()
    delete_signing_data()
}

signing_persistency --> eddsa_signing_metadata


class cmp_ecdsa_online_signing_service {
    start_signing()
    store_commitments()
    broadcast_si()
    get_eddsa_signature()

    cancel_signing()

    platform_service _service
    cmp_key_persistency _key_persistency
    signing_persistency _signing_persistency
}

cmp_ecdsa_online_signing_service --> signing_persistency

package offline {

    class cmp_signature_preprocessed_data {
        elliptic_curve_scalar k
        elliptic_curve_scalar chi
        elliptic_curve_point R
    }

    abstract class preprocessing_persistency {
        store_preprocessing_metadata()
        load_preprocessing_metadata()

        store_preprocessing_data()
        load_preprocessing_data()
        delete_preprocessing_data()
    
        create_preprocessed_data()
        store_preprocessed_data()
        load_preprocessed_data()
        delete_preprocessed_data()
    }

    preprocessing_persistency --> cmp_signature_preprocessed_data


    class cmp_ecdsa_offline_signing_service  {
        start_ecdsa_signature_preprocessing()
        offline_mta_response()
        offline_mta_verify()

        store_presigning_data()
        ecdsa_sign()
        ecdsa_offline_signature()
        cancel_preprocessing()
        preprocessing_persistency _preprocessing_persistency
        mutex _timing_map_lock
        map<string, uint64_t> _timing_map
    }

    cmp_ecdsa_offline_signing_service --> preprocessing_persistency


    abstract class offline_refresh_key_persistency {
        load_refresh_key_seeds()
        
        store_refresh_key_seeds()
        delete_refresh_key_seeds()
        
        transform_preprocessed_data_and_store_temporary()
        commit()

        delete_temporary_key()
        store_temporary_key()
    }


    class cmp_offline_refresh_service {
        refresh_key_request()
        
        refresh_key()
        refresh_key_fast_ack()
        cancel_refresh_key()

        get_algebra()

        platform_service _service
        cmp_key_persistency _key_persistency
        offline_refresh_key_persistency _refresh_key_persistency
    }
    cmp_offline_refresh_service --> offline_refresh_key_persistency
    cmp_offline_refresh_service --> cmp_key_persistency

}

class cmp_ecdsa_signing_service {
    create_mta_request()
    ack_mta_request()
    create_mta_response()
    mta_verify()

    calc_R()
    derivation_key_delta()
    make_sig_s_positive()
    build_aad()
    get_algebra()
    
    platform_service _service
    cmp_key_persistency _key_persistency
}
note right
this class holds the common functionality for 
* cmp_ecdsa_online_signing_service and 
* cmp_ecdsa_offline_signing_service
end note


cmp_ecdsa_signing_service --> platform_service
cmp_ecdsa_signing_service --> cmp_key_persistency
cmp_ecdsa_signing_service --> cmp_mta_request

cmp_ecdsa_offline_signing_service --|>  cmp_ecdsa_signing_service
cmp_ecdsa_online_signing_service --|>  cmp_ecdsa_signing_service



@enduml
